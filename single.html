<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Animal Behavior — Schelling's Model</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8yIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3OTYuNjIgNjE3LjY1Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9PC9zdHlsZT48L2RlZnM+PGcgaWQ9IkxheWVyXzEtMiI+PHBvbHlnb24gY2xhc3M9ImNscy0xIiBwb2ludHM9IjE4MC4xNiA0MTguNzkgMTgwLjE2IDQxNy42IDE4MC4xNiAzOTcuNzEgMTU5LjA4IDM5Ny43MSAxNTkuMDggNDE3LjYgMTU5LjA4IDQxOC43OSAxNTkuMDggNDM4LjY4IDE3OC45NyA0MzguNjggMTc4Ljk3IDQ1Ny4zNyAxNzguOTcgNDU4LjU2IDE3OC45NyA0NzcuMjUgMTU5LjA4IDQ3Ny4yNSAxNTkuMDggNDk3LjE0IDE0MC4zOSA0OTcuMTQgMTM5LjIgNDk3LjE0IDExOS4zMSA0OTcuMTQgMTE5LjMxIDUxOC4yMiAxMzkuMiA1MTguMjIgMTQwLjM5IDUxOC4yMiAxNTkuMDggNTE4LjIyIDE2MC4yOCA1MTguMjIgMTgwLjE2IDUxOC4yMiAxODAuMTYgNDk4LjMzIDIwMC4wNSA0OTguMzMgMjAwLjA1IDQ3OC40NSAyMDAuMDUgNDc3LjI1IDIwMC4wNSA0NTguNTYgMjAwLjA1IDQ1Ny4zNyAyMDAuMDUgNDM3LjQ4IDE4MC4xNiA0MzcuNDggMTgwLjE2IDQxOC43OSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTc3Ni43Myw0OTcuMTR2LTE5Ljg5aC0zOS43N3YtMTkuODloLTc5LjU0di0xOS44OWgtMTkuODl2LTc5LjU0aC0xOS44OXYtNzkuNTRoLTE5Ljg5di01OS42NmgtMTkuODl2LTE5Ljg5aC0xOS44OXYtMTkuODloLTE5Ljg5di0xOS44OWgtMTkuODl2LTE5Ljg5aC05OS40M1YzOS43N2gtMTkuODl2LTE5Ljg5aC0xOS44OVYwaC04MC43NHYxOS44OWgtMTkuODl2MTkuODloLTE5Ljg5djk5LjQzaC0xOC42OXYtMTkuODloLTgwLjc0djE5Ljg5aC0zOS43N3YxOS44OWgtMTguNjl2LTE5Ljg5aC0xOS44OVY0MC45NmgxOS44OXYtMTkuODloNzguMzV2MTkuODloMjEuMDh2LTIxLjA4aC0xOS44OVYwaC04MC43NHYxOS44OWgtMTkuODl2MTkuODloLTE5Ljg5djEwMC42MmgxOS44OXYxOS44OWgxOS44OXYxOC42OWgtMTkuODl2MTkuODloLTE5Ljg5djU5LjY2aC0xOS44OXYxOS44OWgtMTkuODl2MTkuODlIMHYyMS4wOGgzOS43N3YzOS43N2gxOTguODZ2NTkuNjZoMTkuODl2MTkuODloMTkuODl2MzguNThoLTE5Ljg5djE5Ljg5aC0xOS44OXYyMS4wOGg4MC43NHYtMTkuODloMTkuODl2LTE5Ljg5aDE5Ljg5di0zOS43N2g1OS42NnYtMTE5LjMxaDE4LjY5djExOS4zMWgxOS44OXYxOS44OWgxOS44OXYxOS44OWg1OS42NnYxOC42OWgtMTM5LjJ2MjEuMDhoMTgwLjE2di0xOS44OWgxOS44OXYtMTkuODloMTkuODl2LTE5Ljg5aDE4LjY5djE5Ljg5aDk5LjQzdjE5Ljg5aDM5Ljc3djU4LjQ2aC0xOS44OXYxOS44OWgtNTkuNjZ2MTkuODloLTI1OC41MXYyMS4wOGgyNTkuNzF2LTE5Ljg5aDU5LjY2di0xOS44OWgxOS44OXYtMTkuODloMTkuODl2LTYwLjg1aC0xOS44OVpNMzU5LjEzLDE4MC4xNmgxOC42OXYxOC42OWgtMTguNjl2LTE4LjY5Wk0zNzkuMDIsMTYwLjI4aDE4LjY5djE4LjY5aC0xOC42OXYtMTguNjlaTTM5OC45LDE0MC4zOWgxOC42OXYxOC42OWgtMTguNjl2LTE4LjY5Wk0xNzguOTcsMjE5LjkzaDE5Ljg5djM4LjU4aC0zOC41OHYtMzguNThoMTguNjlaTTMxOC4xNywyOTkuNDh2MTguNjloLTE4LjY5di0xOC42OWgxOC42OVpNMjk4LjI4LDMxOS4zNnYxOC42OWgtMTguNjl2LTE4LjY5aDE4LjY5Wk00NzcuMjUsMjc5LjU5aDM5Ljc3djE4LjY5aC01OC40NnYtMTguNjloMTguNjlaTTQwLjk2LDI5OS40OGgxOC42OXYxOC42OWgtMTguNjl2LTE4LjY5Wk0yMzkuODIsMzM5LjI1aDM4LjU4djE4LjY5aC0zOC41OHYtMTguNjlaTTQzOC42OCwyOTkuNDhoMTguNjl2MTguNjloLTE4LjY5di0xOC42OVpNMjc5LjU5LDExOS4zMVY0MC45NmgxOS44OXYtMTkuODloNzguMzV2MTkuODloMTkuODl2OTguMjNoLTE5Ljg5djE5Ljg5aC0xOS44OXYxOS44OWgtNTguNDZ2LTE5Ljg5aC0xOS44OXYtMzkuNzdaIi8+PC9nPjwvc3ZnPg==" />
    <style>
:root {
  --bg: #0e0f14;
  --panel: #141720;
  --panel-2: #191d29;
  --text: #e7ebf2;
  --muted: #a9b1c6;
  --primary: #5b8cff;
  --primary-strong: #3a6df5;
  --accent: #ff6b6b;
  --grid-border: #252a36;
  --chip-a: #2d88ff;
  --chip-b: #ff4757;
  --chip-empty: #2a2f3d;
}

* { box-sizing: border-box; }
html, body { height: 100%; }
body {
  margin: 0;
  color: var(--text);
  background: radial-gradient(1200px 600px at 80% -10%, #1c2130, #0e0f14);
  font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif;
}

.app-header {
  display: flex;
  align-items: center;
  padding: 14px 20px;
  border-bottom: 1px solid #1b2030;
  background: linear-gradient(180deg, rgba(40,45,61,0.25), rgba(20,23,32,0.25));
  backdrop-filter: blur(6px);
  position: sticky;
  top: 0;
  z-index: 10;
}
.brand { display: flex; align-items: center; gap: 12px; }
.sim-tabs-header { display: flex; gap: 10px; margin-left: auto; margin-right: 18px; }
.tab { cursor: pointer; padding: 8px 10px; border-radius: 10px; border: 1px solid #23293a; color: var(--text); background: var(--panel); font-weight: 700; }
.tab.active { filter: brightness(1.05); }
.tab-schelling.active { background: linear-gradient(180deg, #a78bfa, #8b5cf6); border-color: rgba(0,0,0,0.15); }
.tab-life.active { background: linear-gradient(180deg, #34d399, #10b981); border-color: rgba(0,0,0,0.15); }
.tab-boids.active { background: linear-gradient(180deg, #fbbf24, #f59e0b); border-color: rgba(0,0,0,0.15); }
.app-icon { width: 34px; height: 34px; border-radius: 8px; display: block; box-shadow: 0 2px 6px rgba(0,0,0,0.25); }
.titles h1 { margin: 0; font-size: 16px; font-weight: 700; }
.titles p { margin: 0; margin-top: 2px; font-size: 12px; color: var(--muted); }
.titles .subtitle { color: var(--muted); }
.sim-title { display: inline-block; margin-top: 4px; font-size: 12px; font-weight: 700; color: #9ad8c7; text-decoration: none; }
.sim-title:hover { text-decoration: underline; }
.controls .sim-title { margin: 10px 0 8px; font-size: 18px; font-weight: 800; letter-spacing: 0.2px; }
.sim-title.schelling { color: var(--primary); }
.sim-title.life { color: #10b981; }
.spacer { flex: 1; }
.header-link { color: var(--muted); text-decoration: none; opacity: 0.7; cursor: default; }
.huji-logo { height: 34px; width: auto; opacity: 0.9; filter: drop-shadow(0 1px 0 rgba(0,0,0,0.2)); margin-left: 12px; }

.layout {
  display: grid;
  grid-template-columns: 360px 1fr 320px;
  gap: 16px;
  padding: 16px;
  max-width: 1600px;
  margin: 0 auto;
}

.panel {
  background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
  border: 1px solid #1a1f2c;
  border-radius: 14px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04);
}

.controls { padding: 16px; }
.controls h2 { margin: 4px 0 12px; font-size: 16px; font-weight: 800; letter-spacing: 0.2px; }

.sim-tabs { display: flex; gap: 8px; margin-bottom: 12px; }
.tab { cursor: pointer; padding: 8px 10px; border-radius: 10px; border: 1px solid #23293a; color: var(--text); background: var(--panel); font-weight: 700; }
.tab.active { background: linear-gradient(180deg, var(--primary), var(--primary-strong)); border-color: rgba(0,0,0,0.15); }
.sim-panel { }

.control-group { margin-bottom: 14px; }
.control-group.sm { width: 50%; }
label { display: block; font-weight: 600; margin-bottom: 6px; color: var(--muted); }
small { display: block; margin-top: 4px; color: #8f99b2; }

input[type="range"] { width: 100%; }
input[type="range"]::-webkit-slider-thumb { cursor: pointer; }
input[type="number"] {
  width: 100%;
  padding: 8px 10px;
  border-radius: 10px; border: 1px solid #232938;
  background: var(--panel);
  color: var(--text);
}
select {
  width: 100%;
  padding: 8px 10px;
  border-radius: 10px; border: 1px solid #232938;
  background: var(--panel);
  color: var(--text);
}

.row { display: flex; gap: 12px; align-items: center; }
.checkbox { display: flex; align-items: center; gap: 8px; color: var(--muted); }
.checkbox input { transform: translateY(1px); }

.buttons { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 8px; align-items: center; }
.buttons .btn-right { margin-left: auto; display: flex; gap: 10px; }
.btn {
  appearance: none; border: none; outline: none; cursor: pointer;
  padding: 10px 14px; border-radius: 12px; font-weight: 700; letter-spacing: 0.2px;
  color: var(--text);
  background: linear-gradient(180deg, var(--panel-2), var(--panel));
  border: 1px solid #23293a;
  box-shadow: 0 6px 16px rgba(0,0,0,0.22), inset 0 1px 0 rgba(255,255,255,0.06);
}
.btn .icon { display: inline-block; width: 1.1em; height: 1.1em; margin-right: 6px; vertical-align: -0.15em; }
.btn .icon svg { width: 100%; height: 100%; fill: currentColor; display: inline-block; }
.btn .icon .pause { display: none; }
.btn.running .icon .play { display: none; }
.btn.running .icon .pause { display: inline-block; }
.btn:hover { filter: brightness(1.06); }
.btn.primary { background: linear-gradient(180deg, var(--primary), var(--primary-strong)); border-color: rgba(0,0,0,0.15); }
.btn.danger { background: linear-gradient(180deg, #ff6b6b, #e84a4a); border-color: rgba(0,0,0,0.15); }
.btn.fixed { min-width: 82px; }

.stats { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 14px; }
.stat { display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; border-radius: 10px; background: var(--panel); border: 1px solid #23293a; }
.stat .label { color: var(--muted); }

.canvas-panel { display: flex; flex-direction: column; }
.canvas-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 14px; border-bottom: 1px solid #1a1f2c; }
.legend { display: flex; gap: 12px; color: var(--muted); }
.legend-item { display: inline-flex; align-items: center; gap: 6px; }
.chip { display: inline-block; width: 12px; height: 12px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.15); }
.chip.a { background: var(--chip-a); }
.chip.b { background: var(--chip-b); }
.chip.empty { background: var(--chip-empty); }
.chip.life-alive { background: #7ee7c4; }
.chip.life-dead { background: #1a1f2c; }

/* Ensure only the relevant legend is visible for the active simulation */
.sim-schelling #lifeLegend { display: none !important; }
.sim-life #schellingLegend { display: none !important; }
.sim-boids #schellingLegend, .sim-boids #lifeLegend { display: none !important; }
.sim-schelling #boidsLegend, .sim-life #boidsLegend { display: none !important; }

/* Boids title accent */
.sim-title.boids { color: #f59e0b; }
.canvas-wrap { padding: 16px; }

canvas#gridCanvas {
  width: 100%;
  height: calc(100vh - 220px);
  max-height: 1100px;
  display: block;
  background: linear-gradient(180deg, #0f121a, #0c0f14);
  border-radius: 12px;
  border: 1px solid #1a1f2c;
  box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02), 0 10px 26px rgba(0,0,0,0.35);
}

.app-footer {
  padding: 10px 16px; color: var(--muted); text-align: center;
  border-top: 1px solid #1b2030; margin-top: 10px;
}

.rules { padding: 16px; }
.rules h2 { margin: 4px 0 12px; font-size: 16px; font-weight: 800; letter-spacing: 0.2px; }
.rules h3 { margin: 10px 0 8px; font-size: 13px; font-weight: 800; color: var(--text); }
.rules ul { margin: 0; padding-left: 18px; color: var(--muted); }
.rules li { margin: 8px 0; }
.rules .note {
  margin-top: 12px; padding: 10px 12px; border-radius: 10px;
  background: var(--panel); border: 1px solid #23293a; color: var(--text);
}

/* Responsive */
@media (max-width: 980px) {
  .layout { grid-template-columns: 1fr; }
  canvas#gridCanvas { height: 65vh; }
}

</style>
  </head>
  <body>
    <header class="app-header">
      <div class="brand">
        <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8yIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3OTYuNjIgNjE3LjY1Ij48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2ZmZjt9PC9zdHlsZT48L2RlZnM+PGcgaWQ9IkxheWVyXzEtMiI+PHBvbHlnb24gY2xhc3M9ImNscy0xIiBwb2ludHM9IjE4MC4xNiA0MTguNzkgMTgwLjE2IDQxNy42IDE4MC4xNiAzOTcuNzEgMTU5LjA4IDM5Ny43MSAxNTkuMDggNDE3LjYgMTU5LjA4IDQxOC43OSAxNTkuMDggNDM4LjY4IDE3OC45NyA0MzguNjggMTc4Ljk3IDQ1Ny4zNyAxNzguOTcgNDU4LjU2IDE3OC45NyA0NzcuMjUgMTU5LjA4IDQ3Ny4yNSAxNTkuMDggNDk3LjE0IDE0MC4zOSA0OTcuMTQgMTM5LjIgNDk3LjE0IDExOS4zMSA0OTcuMTQgMTE5LjMxIDUxOC4yMiAxMzkuMiA1MTguMjIgMTQwLjM5IDUxOC4yMiAxNTkuMDggNTE4LjIyIDE2MC4yOCA1MTguMjIgMTgwLjE2IDUxOC4yMiAxODAuMTYgNDk4LjMzIDIwMC4wNSA0OTguMzMgMjAwLjA1IDQ3OC40NSAyMDAuMDUgNDc3LjI1IDIwMC4wNSA0NTguNTYgMjAwLjA1IDQ1Ny4zNyAyMDAuMDUgNDM3LjQ4IDE4MC4xNiA0MzcuNDggMTgwLjE2IDQxOC43OSIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTc3Ni43Myw0OTcuMTR2LTE5Ljg5aC0zOS43N3YtMTkuODloLTc5LjU0di0xOS44OWgtMTkuODl2LTc5LjU0aC0xOS44OXYtNzkuNTRoLTE5Ljg5di01OS42NmgtMTkuODl2LTE5Ljg5aC0xOS44OXYtMTkuODloLTE5Ljg5di0xOS44OWgtMTkuODl2LTE5Ljg5aC05OS40M1YzOS43N2gtMTkuODl2LTE5Ljg5aC0xOS44OVYwaC04MC43NHYxOS44OWgtMTkuODl2MTkuODloLTE5Ljg5djk5LjQzaC0xOC42OXYtMTkuODloLTgwLjc0djE5Ljg5aC0zOS43N3YxOS44OWgtMTguNjl2LTE5Ljg5aC0xOS44OVY0MC45NmgxOS44OXYtMTkuODloNzguMzV2MTkuODloMjEuMDh2LTIxLjA4aC0xOS44OVYwaC04MC43NHYxOS44OWgtMTkuODl2MTkuODloLTE5Ljg5djEwMC42MmgxOS44OXYxOS44OWgxOS44OXYxOC42OWgtMTkuODl2MTkuODloLTE5Ljg5djU5LjY2aC0xOS44OXYxOS44OWgtMTkuODl2MTkuODlIMHYyMS4wOGgzOS43N3YzOS43N2gxOTguODZ2NTkuNjZoMTkuODl2MTkuODloMTkuODl2MzguNThoLTE5Ljg5djE5Ljg5aC0xOS44OXYyMS4wOGg4MC43NHYtMTkuODloMTkuODl2LTE5Ljg5aDE5Ljg5di0zOS43N2g1OS42NnYtMTE5LjMxaDE4LjY5djExOS4zMWgxOS44OXYxOS44OWgxOS44OXYxOS44OWg1OS42NnYxOC42OWgtMTM5LjJ2MjEuMDhoMTgwLjE2di0xOS44OWgxOS44OXYtMTkuODloMTkuODl2LTE5Ljg5aDE4LjY5djE5Ljg5aDk5LjQzdjE5Ljg5aDM5Ljc3djU4LjQ2aC0xOS44OXYxOS44OWgtNTkuNjZ2MTkuODloLTI1OC41MXYyMS4wOGgyNTkuNzF2LTE5Ljg5aDU5LjY2di0xOS44OWgxOS44OXYtMTkuODloMTkuODl2LTYwLjg1aC0xOS44OVpNMzU5LjEzLDE4MC4xNmgxOC42OXYxOC42OWgtMTguNjl2LTE4LjY5Wk0zNzkuMDIsMTYwLjI4aDE4LjY5djE4LjY5aC0xOC42OXYtMTguNjlaTTM5OC45LDE0MC4zOWgxOC42OXYxOC42OWgtMTguNjl2LTE4LjY5Wk0xNzguOTcsMjE5LjkzaDE5Ljg5djM4LjU4aC0zOC41OHYtMzguNThoMTguNjlaTTMxOC4xNywyOTkuNDh2MTguNjloLTE4LjY5di0xOC42OWgxOC42OVpNMjk4LjI4LDMxOS4zNnYxOC42OWgtMTguNjl2LTE4LjY5aDE4LjY5Wk00NzcuMjUsMjc5LjU5aDM5Ljc3djE4LjY5aC01OC40NnYtMTguNjloMTguNjlaTTQwLjk2LDI5OS40OGgxOC42OXYxOC42OWgtMTguNjl2LTE4LjY5Wk0yMzkuODIsMzM5LjI1aDM4LjU4djE4LjY5aC0zOC41OHYtMTguNjlaTTQzOC42OCwyOTkuNDhoMTguNjl2MTguNjloLTE4LjY5di0xOC42OVpNMjc5LjU5LDExOS4zMVY0MC45NmgxOS44OXYtMTkuODloNzguMzV2MTkuODloMTkuODl2OTguMjNoLTE5Ljg5djE5Ljg5aC0xOS44OXYxOS44OWgtNTguNDZ2LTE5Ljg5aC0xOS44OXYtMzkuNzdaIi8+PC9nPjwvc3ZnPg==" alt="Animal Behavior icon" class="app-icon" />
        <div class="titles">
          <h1>Animal Behavior Simulations</h1>
          <p class="subtitle">A HUJI Course on Animal Behavior and Cognition</p>
        </div>
      </div>
      <div class="spacer"></div>
      <div class="sim-tabs-header" role="tablist" aria-label="Simulation selector">
        <button id="tabSchelling" class="tab tab-schelling active" role="tab" aria-selected="true" aria-controls="schellingPanel">Schelling</button>
        <button id="tabLife" class="tab tab-life" role="tab" aria-selected="false" aria-controls="lifePanel">Game of Life</button>
        <button id="tabBoids" class="tab tab-boids" role="tab" aria-selected="false" aria-controls="boidsPanel">Boids</button>
      </div>
      <img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3Ny4xOCAxNDEuNzMiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDojZmZmO308L3N0eWxlPjwvZGVmcz48cG9seWdvbiBjbGFzcz0iY2xzLTEiIHBvaW50cz0iNTEuMzcgNjIuNzQgNDEuMDYgNzUuNTMgNjcuODUgMTE1Ljc0IDczLjc1IDEwOC4xNSA1MS4zNyA2Mi43NCIvPjxwYXRoIGNsYXNzPSJjbHMtMSIgZD0iTTI3Ljc2LDYuNDJsLTMuMTItNi40MnMtNi42NiwxMC4xOC02LjY2LDE0LjE0YzAsNi4yOCwyLjk1LDEwLjQyLDIuOTUsMTAuNDJoOS4xM2wxLjYyLTkuODVoLTUuODdsMS45My04LjI5WiIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMSIgcG9pbnRzPSI2OC4wOCA5MC44NiA3Ny4xOCA3OS4xNyA3Mi45MiA3MC41MyA2Mi44OCA4MC4zMiA2OC4wOCA5MC44NiIvPjxwb2x5Z29uIGNsYXNzPSJjbHMtMSIgcG9pbnRzPSIzMS43NSA4Mi45OCAyOS4xOSAzMC4xNiAyMS42OSAzMC4xNiAxNy4zNiAxMDAuNzcgMzEuNzUgODIuOTgiLz48cG9seWdvbiBjbGFzcz0iY2xzLTEiIHBvaW50cz0iMzkuMzggNzcuNiAwIDEyNi4yOSAwIDE0MS43MyA0OS43MyA5My4xNCAzOS4zOCA3Ny42Ii8+PC9zdmc+" alt="The Hebrew University of Jerusalem" class="huji-logo" />
    </header>

    <main class="layout">
      <section class="panel controls">
        <a id="simTitle" class="sim-title" href="https://en.wikipedia.org/wiki/Schelling%27s_model_of_segregation" target="_blank" rel="noopener">Schelling's Model of Segregation</a>
        <h2>Controls</h2>

        <div class="control-group" id="gridSizeGroup">
          <label for="gridSize">Grid size: <span id="gridSizeValue">40</span> × <span id="gridSizeValue2">40</span></label>
          <input id="gridSize" type="range" min="10" max="120" step="1" value="40" />
        </div>

        <div class="control-group" id="densityGroup">
          <label for="density">Occupancy (% filled): <span id="densityValue">90</span>%</label>
          <input id="density" type="range" min="0" max="100" step="1" value="90" />
        </div>

        <div id="schellingPanel" class="sim-panel" role="tabpanel" aria-labelledby="tabSchelling">
          <div class="control-group">
            <label for="ratioA">Type A ratio (of agents): <span id="ratioAValue">50</span>%</label>
            <input id="ratioA" type="range" min="0" max="100" step="1" value="50" />
          </div>

          <div class="control-group">
            <label for="tolerance">Minimum similar neighbors: <span id="toleranceValue">50</span>%</label>
            <input id="tolerance" type="range" min="0" max="100" step="1" value="50" />
            <small>Agents are satisfied if at least this percent of neighbors are the same type.</small>
          </div>
        </div>

        <div id="lifePanel" class="sim-panel" role="tabpanel" aria-labelledby="tabLife" hidden>
          <div class="control-group">
            <label for="lifePattern">Initial pattern</label>
            <select id="lifePattern">
              <option value="random" selected>Random</option>
              <option value="glider">Glider</option>
              <option value="blinker">Blinker</option>
              <option value="pulsar">Pulsar</option>
              <option value="gosper">Gosper Glider Gun</option>
            </select>
          </div>
        </div>

        <div id="boidsPanel" class="sim-panel" role="tabpanel" aria-labelledby="tabBoids" hidden>
          <div class="row">
            <div class="control-group sm">
              <label for="boidsCount">Boids: <span id="boidsCountValue">150</span></label>
              <input id="boidsCount" type="range" min="10" max="1000" step="10" value="150" />
            </div>
            <div class="control-group sm">
              <label for="perception">Perception radius: <span id="perceptionValue">50</span></label>
              <input id="perception" type="range" min="10" max="200" step="5" value="50" />
            </div>
          </div>
          <div class="row">
            <div class="control-group sm">
              <label for="separationDist">Separation distance: <span id="separationDistValue">20</span></label>
              <input id="separationDist" type="range" min="5" max="100" step="1" value="20" />
            </div>
            <div class="control-group sm">
              <label for="maxSpeed">Max speed: <span id="maxSpeedValue">2.5</span></label>
              <input id="maxSpeed" type="range" min="0.5" max="6" step="0.1" value="2.5" />
            </div>
          </div>
          <div class="row">
            <div class="control-group sm">
              <label for="maxForce">Max force: <span id="maxForceValue">0.05</span></label>
              <input id="maxForce" type="range" min="0.01" max="0.5" step="0.01" value="0.05" />
            </div>
            <div class="control-group sm"></div>
          </div>
          <div class="row">
            <div class="control-group sm">
              <label for="weightSep">Separation weight: <span id="weightSepValue">1.5</span></label>
              <input id="weightSep" type="range" min="0" max="3" step="0.1" value="1.5" />
            </div>
            <div class="control-group sm">
              <label for="weightAlign">Alignment weight: <span id="weightAlignValue">1.0</span></label>
              <input id="weightAlign" type="range" min="0" max="3" step="0.1" value="1.0" />
            </div>
          </div>
          <div class="row">
            <div class="control-group sm">
              <label for="weightCoh">Cohesion weight: <span id="weightCohValue">1.0</span></label>
              <input id="weightCoh" type="range" min="0" max="3" step="0.1" value="1.0" />
            </div>
            <div class="control-group sm"></div>
          </div>
          
        </div>

        <div class="row">
          <div class="control-group sm">
            <label for="delay">Step delay (ms): <span id="delayValue">100</span></label>
            <input id="delay" type="range" min="0" max="1000" step="10" value="100" />
          </div>
          <div class="control-group sm">
            <label for="maxIterations">Max steps</label>
            <input id="maxIterations" type="number" min="1" max="20000" step="1" value="5000" />
          </div>
        </div>

        <div class="row">
          <label class="checkbox">
            <input id="wrapEdges" type="checkbox" />
            <span>Wrap edges (toroidal)</span>
          </label>
        </div>
        <div class="row" id="unsatRow">
          <label class="checkbox">
            <input id="showUnsatisfied" type="checkbox" checked />
            <span>Show unsatisfied markers</span>
          </label>
        </div>

        <div class="buttons">
          <button id="initializeBtn" class="btn" title="Initialize a new random grid">Initialize</button>
          <div class="btn-right">
            <button id="stepBtn" class="btn fixed" title="Advance one step">
              <span class="icon" aria-hidden="true">
                <svg viewBox="0 0 16 16"><path d="M10 2v12h2V2h-2zM2 2v12l7-6-7-6z"/></svg>
              </span>
              <span class="label">Step</span>
            </button>
            <button id="runBtn" class="btn danger fixed" title="Run until convergence with delay">
              <span class="icon" aria-hidden="true">
                <svg class="play" viewBox="0 0 16 16"><path d="M3 2v12l10-6L3 2z"/></svg>
                <svg class="pause" viewBox="0 0 16 16"><path d="M3 2h4v12H3zM9 2h4v12H9z"/></svg>
              </span>
              <span class="label">Run</span>
            </button>
          </div>
        </div>

        <div class="stats">
          <div class="stat"><span class="label">Step</span><span id="statStep">0</span></div>
          <div class="stat"><span class="label">Agents</span><span id="statAgents">0</span></div>
          <div class="stat"><span class="label">Unsatisfied</span><span id="statUnsatisfied">0</span></div>
          <div class="stat"><span class="label">Satisfied</span><span id="statSatisfied">0%</span></div>
          <div class="stat"><span class="label">Moved (last)</span><span id="statMoved">0</span></div>
        </div>
      </section>

      <section class="panel canvas-panel">
        <div class="canvas-header">
          <div class="legend" id="schellingLegend">
            <div class="legend-item"><span class="chip a"></span>Type A</div>
            <div class="legend-item"><span class="chip b"></span>Type B</div>
            <div class="legend-item"><span class="chip empty"></span>Empty</div>
          </div>
          <div class="legend" id="lifeLegend" hidden>
            <div class="legend-item"><span class="chip life-alive"></span>Alive</div>
            <div class="legend-item"><span class="chip life-dead"></span>Dead</div>
          </div>
          <div class="legend" id="boidsLegend" hidden>
            <div class="legend-item"><span class="chip life-alive"></span>Boid</div>
          </div>
        </div>
        <div class="canvas-wrap">
          <canvas id="gridCanvas" width="900" height="900" aria-label="Schelling grid" role="img"></canvas>
        </div>
      </section>

      <aside class="panel rules">
        <h2>Model Rules</h2>

        <div id="schellingRules">
          <h3>Core Rules</h3>
          <ul>
            <li><b>Agents:</b> Two types: A (blue) and B (red). Empty cells are gray.</li>
            <li><b>Neighborhood:</b> Moore neighborhood (8 surrounding cells).</li>
            <li><b>Tolerance:</b> An agent is satisfied if at least the selected percent of its non-empty neighbors are the same type.</li>
            <li><b>No neighbors:</b> Agents with zero neighbors are considered satisfied.</li>
            <li><b>Update rule:</b> In each iteration, all unsatisfied agents relocate in parallel to randomly chosen empty cells.</li>
            <li><b>Convergence:</b> Reached when no agents are unsatisfied or no empty cells remain.</li>
          </ul>
          <h3>Simulation Options</h3>
          <ul>
            <li><b>Wrap edges:</b> When enabled, the grid is a torus; when disabled, borders are bounds. Manual moves and distance calculations respect this.</li>
            <li><b>Step/Run:</b> Advance one iteration or run until convergence using the model’s update rule.</li>
            <li><b>Manual move:</b> Clicking an unsatisfied agent moves it to the nearest empty cell that would satisfy it (if any); otherwise to a random empty cell.</li>
            <li><b>Markers:</b> Toggle <i>Show unsatisfied markers</i> to highlight agents that want to move.</li>
          </ul>
        </div>

        <div id="lifeRules" hidden>
          <h3>Core Rules</h3>
          <ul>
            <li><b>Cells:</b> Each cell is either <i>alive</i> or <i>dead</i>.</li>
            <li><b>Neighborhood:</b> Moore neighborhood (8 surrounding cells).</li>
            <li><b>Birth:</b> A dead cell with exactly 3 live neighbors becomes alive.</li>
            <li><b>Survival:</b> A live cell with 2 or 3 live neighbors stays alive; otherwise it dies.</li>
            <li><b>Sync update:</b> All cells update simultaneously each step.</li>
          </ul>
          <h3>Simulation Options</h3>
          <ul>
            <li><b>Wrap edges:</b> When enabled, the grid is a torus; when disabled, borders are bounds.</li>
            <li><b>Step/Run:</b> Advance a single generation or continuously with a delay.</li>
            <li><b>Initialize:</b> Use <i>Occupancy</i> for random seeds or pick a preset pattern (Glider, Blinker, Pulsar, Gosper Gun).</li>
            <li><b>Edit:</b> Click the grid to toggle cells alive/dead.</li>
          </ul>
        </div>

        <div id="boidsRules" hidden>
          <h3>Core Rules</h3>
          <ul>
            <li><b>Agents:</b> Boids move in continuous space with position and velocity.</li>
            <li><b>Perception:</b> Each boid senses neighbors within a radius.</li>
            <li><b>Separation:</b> Steer to avoid crowding neighbors closer than a separation distance.</li>
            <li><b>Alignment:</b> Steer towards the average direction of nearby boids.</li>
            <li><b>Cohesion:</b> Steer towards the average position (center) of nearby boids.</li>
            <li><b>Limits:</b> Acceleration is limited by <i>max force</i>, speed by <i>max speed</i>.</li>
          </ul>
          <h3>Simulation Options</h3>
          <ul>
            <li><b>Wrap edges:</b> When enabled, boids wrap around; otherwise they bounce at borders.</li>
            <li><b>Sliders:</b> Control boid count, perception radius, separation distance, and weights.</li>
            <li><b>Interaction:</b> Click to add or remove boids (coming soon).</li>
          </ul>
        </div>
      </aside>
    </main>

    <footer class="app-footer">
      <span>Built for demos and simulations in Animal Behavior.</span>
    </footer>

    <script>
/*
  Schelling's Model of Segregation — Interactive Simulation
  - Two agent types (A/B), 0 = empty
  - Neighborhood: Moore radius 1 (8 neighbors)
  - Satisfaction if fraction of similar neighbors >= tolerance
  - Unsatisfied agents move to random empty cells each step (parallel moves)
*/

(function() {
  // DOM elements
  const els = {
    gridSize: document.getElementById('gridSize'),
    gridSizeValue: document.getElementById('gridSizeValue'),
    gridSizeValue2: document.getElementById('gridSizeValue2'),
    density: document.getElementById('density'),
    densityValue: document.getElementById('densityValue'),
    ratioA: document.getElementById('ratioA'),
    ratioAValue: document.getElementById('ratioAValue'),
    tolerance: document.getElementById('tolerance'),
    toleranceValue: document.getElementById('toleranceValue'),
    delay: document.getElementById('delay'),
    delayValue: document.getElementById('delayValue'),
    maxIterations: document.getElementById('maxIterations'),
    wrapEdges: document.getElementById('wrapEdges'),
    showUnsatisfied: document.getElementById('showUnsatisfied'),
    initializeBtn: document.getElementById('initializeBtn'),
    stepBtn: document.getElementById('stepBtn'),
    runBtn: document.getElementById('runBtn'),
    runBtnLabel: document.querySelector('#runBtn .label'),
    simTitle: document.getElementById('simTitle'),
    canvas: document.getElementById('gridCanvas'),
    statStep: document.getElementById('statStep'),
    statAgents: document.getElementById('statAgents'),
    statUnsatisfied: document.getElementById('statUnsatisfied'),
    statSatisfied: document.getElementById('statSatisfied'),
    statMoved: document.getElementById('statMoved'),
    // Tabs and per-sim controls
    tabSchelling: document.getElementById('tabSchelling'),
    tabLife: document.getElementById('tabLife'),
    tabBoids: document.getElementById('tabBoids'),
    schellingPanel: document.getElementById('schellingPanel'),
    lifePanel: document.getElementById('lifePanel'),
    boidsPanel: document.getElementById('boidsPanel'),
    lifePattern: document.getElementById('lifePattern'),
    unsatRow: document.getElementById('unsatRow'),
    schellingRules: document.getElementById('schellingRules'),
    lifeRules: document.getElementById('lifeRules'),
    boidsRules: document.getElementById('boidsRules'),
    schellingLegend: document.getElementById('schellingLegend'),
    lifeLegend: document.getElementById('lifeLegend'),
    boidsLegend: document.getElementById('boidsLegend'),
    // Boids controls
    boidsCount: document.getElementById('boidsCount'),
    boidsCountValue: document.getElementById('boidsCountValue'),
    perception: document.getElementById('perception'),
    perceptionValue: document.getElementById('perceptionValue'),
    separationDist: document.getElementById('separationDist'),
    separationDistValue: document.getElementById('separationDistValue'),
    maxSpeed: document.getElementById('maxSpeed'),
    maxSpeedValue: document.getElementById('maxSpeedValue'),
    maxForce: document.getElementById('maxForce'),
    maxForceValue: document.getElementById('maxForceValue'),
    weightSep: document.getElementById('weightSep'),
    weightSepValue: document.getElementById('weightSepValue'),
    weightAlign: document.getElementById('weightAlign'),
    weightAlignValue: document.getElementById('weightAlignValue'),
    weightCoh: document.getElementById('weightCoh'),
    weightCohValue: document.getElementById('weightCohValue'),
  };

  // Utility: RNG and shuffle
  function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
  }

  // Boids model
  class LifeLikeBoidsPlaceholder {}

  class BoidsModel {
    constructor(opts) {
      this.wrapEdges = !!opts.wrapEdges;
      this.width = opts.width; this.height = opts.height;
      this.perception = opts.perception;
      this.separationDist = opts.separationDist;
      this.maxSpeed = opts.maxSpeed;
      this.maxForce = opts.maxForce;
      this.wSep = opts.wSep; this.wAlign = opts.wAlign; this.wCoh = opts.wCoh;
      this.boids = [];
      for (let i = 0; i < opts.count; i++) {
        this.boids.push({
          x: Math.random() * this.width,
          y: Math.random() * this.height,
          vx: (Math.random() * 2 - 1) * this.maxSpeed,
          vy: (Math.random() * 2 - 1) * this.maxSpeed,
        });
      }
      this.stepCount = 0;
    }
    count() { return this.boids.length; }
    step() {
      const b = this.boids;
      const n = b.length;
      for (let i = 0; i < n; i++) {
        const me = b[i];
        let steerSepX = 0, steerSepY = 0;
        let alignX = 0, alignY = 0, alignCount = 0;
        let cohX = 0, cohY = 0, cohCount = 0;
        
        for (let j = 0; j < n; j++) {
          if (i === j) continue;
          const other = b[j];
          let dx = other.x - me.x, dy = other.y - me.y;
          if (this.wrapEdges) {
            if (Math.abs(dx) > this.width/2) dx -= Math.sign(dx) * this.width;
            if (Math.abs(dy) > this.height/2) dy -= Math.sign(dy) * this.height;
          }
          const d2 = dx*dx + dy*dy;
          if (d2 <= this.perception*this.perception) {
            alignX += other.vx; alignY += other.vy; alignCount++;
            cohX += other.x; cohY += other.y; cohCount++;
            const d = Math.sqrt(d2) || 1e-6;
            if (d < this.separationDist) {
              const inv = 1 / d;
              steerSepX -= dx * inv; steerSepY -= dy * inv;
            }
          }
        }
        
        if (alignCount > 0) {
          alignX /= alignCount; alignY /= alignCount;
          const mag = Math.hypot(alignX, alignY) || 1;
          alignX = (alignX / mag) * this.maxSpeed - me.vx;
          alignY = (alignY / mag) * this.maxSpeed - me.vy;
        }
        if (cohCount > 0) {
          cohX = (cohX / cohCount) - me.x;
          cohY = (cohY / cohCount) - me.y;
          if (this.wrapEdges) {
            if (Math.abs(cohX) > this.width/2) cohX -= Math.sign(cohX)*this.width;
            if (Math.abs(cohY) > this.height/2) cohY -= Math.sign(cohY)*this.height;
          }
          const mag = Math.hypot(cohX, cohY) || 1;
          cohX = (cohX / mag) * this.maxSpeed - me.vx;
          cohY = (cohY / mag) * this.maxSpeed - me.vy;
        }
        const sepMag = Math.hypot(steerSepX, steerSepY) || 0;
        if (sepMag > 0) { steerSepX = (steerSepX/sepMag)*this.maxSpeed - me.vx; steerSepY = (steerSepY/sepMag)*this.maxSpeed - me.vy; }

        let ax = this.wSep * steerSepX + this.wAlign * alignX + this.wCoh * cohX;
        let ay = this.wSep * steerSepY + this.wAlign * alignY + this.wCoh * cohY;
        const aMag = Math.hypot(ax, ay) || 0;
        if (aMag > this.maxForce) { ax = ax / aMag * this.maxForce; ay = ay / aMag * this.maxForce; }

        me.vx += ax; me.vy += ay;
        const vMag = Math.hypot(me.vx, me.vy) || 1;
        if (vMag > this.maxSpeed) { me.vx = me.vx / vMag * this.maxSpeed; me.vy = me.vy / vMag * this.maxSpeed; }
        me.x += me.vx; me.y += me.vy;
        if (this.wrapEdges) {
          if (me.x < 0) me.x += this.width; if (me.x >= this.width) me.x -= this.width;
          if (me.y < 0) me.y += this.height; if (me.y >= this.height) me.y -= this.height;
        } else {
          if (me.x < 0 || me.x > this.width) { me.vx *= -1; me.x = Math.max(0, Math.min(this.width, me.x)); }
          if (me.y < 0 || me.y > this.height) { me.vy *= -1; me.y = Math.max(0, Math.min(this.height, me.y)); }
        }
      }
      this.stepCount++;
      return { changed: true };
    }
  }
  // Conway's Game of Life model
  class LifeModel {
    constructor(size, densityPct, wrapEdges) {
      this.size = size | 0;
      this.wrapEdges = !!wrapEdges;
      this.grid = new Uint8Array(this.size * this.size); // 0 dead, 1 alive
      this.stepCount = 0;
      this.randomize(densityPct);
    }
    index(x, y) { return y * this.size + x; }
    inBounds(x, y) { return x >= 0 && y >= 0 && x < this.size && y < this.size; }
    randomize(densityPct) {
      const p = Math.max(0, Math.min(100, densityPct)) / 100;
      const n = this.size * this.size;
      for (let i = 0; i < n; i++) this.grid[i] = Math.random() < p ? 1 : 0;
      this.stepCount = 0;
    }
    setAllDead() { this.grid.fill(0); }
    neighborsAlive(x, y) {
      let alive = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          let nx = x + dx, ny = y + dy;
          if (this.wrapEdges) {
            nx = (nx + this.size) % this.size;
            ny = (ny + this.size) % this.size;
          } else if (!this.inBounds(nx, ny)) {
            continue;
          }
          alive += this.grid[this.index(nx, ny)] ? 1 : 0;
        }
      }
      return alive;
    }
    step() {
      const next = new Uint8Array(this.grid.length);
      let changes = 0;
      for (let y = 0; y < this.size; y++) {
        for (let x = 0; x < this.size; x++) {
          const idx = this.index(x, y);
          const a = this.grid[idx] === 1;
          const n = this.neighborsAlive(x, y);
          let nv = 0;
          if (a) nv = (n === 2 || n === 3) ? 1 : 0;
          else nv = (n === 3) ? 1 : 0;
          next[idx] = nv;
          if (nv !== this.grid[idx]) changes++;
        }
      }
      this.grid = next;
      this.stepCount++;
      return { changed: changes };
    }
    countAlive() {
      let alive = 0;
      for (let i = 0; i < this.grid.length; i++) alive += this.grid[i];
      return alive;
    }
    seedPattern(name) {
      this.setAllDead();
      const s = this.size;
      const cx = Math.floor(s / 2), cy = Math.floor(s / 2);
      const set = (x, y) => { if (x>=0&&y>=0&&x<s&&y<s) this.grid[this.index(x,y)] = 1; };
      if (name === 'glider') {
        [[1,0],[2,1],[0,2],[1,2],[2,2]].forEach(([dx,dy])=>set(cx+dx-1, cy+dy-1));
      } else if (name === 'blinker') {
        [[-1,0],[0,0],[1,0]].forEach(([dx,dy])=>set(cx+dx, cy+dy));
      } else if (name === 'pulsar') {
        const coords = [
          [-6,-4],[-5,-4],[-4,-4],[-2,-4],[-1,-4],[0,-4],[2,-4],[3,-4],[4,-4],
          [-6,4],[-5,4],[-4,4],[-2,4],[-1,4],[0,4],[2,4],[3,4],[4,4],
          [-4,-6],[-4,-5],[-4,-4],[-4,-2],[-4,-1],[-4,0],[4,-6],[4,-5],[4,-4],[4,-2],[4,-1],[4,0],
          [-1,-1],[-1,-2],[-1,-4],[-1,-5],[-1,-6],[1,-1],[1,-2],[1,-4],[1,-5],[1,-6],
          [-1,1],[-1,2],[-1,4],[-1,5],[-1,6],[1,1],[1,2],[1,4],[1,5],[1,6],
          [-4,6],[-4,5],[-4,4],[-4,2],[-4,1],[-4,0],[4,6],[4,5],[4,4],[4,2],[4,1],[4,0]
        ];
        coords.forEach(([dx,dy])=>set(cx+dx, cy+dy));
      } else if (name === 'gosper') {
        const gun = [
          [1,5],[1,6],[2,5],[2,6],
          [13,3],[14,3],[12,4],[16,4],[11,5],[17,5],[11,6],[15,6],[17,6],[18,6],[11,7],[17,7],[12,8],[16,8],[13,9],[14,9],
          [23,1],[24,1],[22,2],[26,2],[21,3],[27,3],[21,4],[25,4],[27,4],[28,4],[21,5],[27,5],[22,6],[26,6],[23,7],[24,7],
          [35,3],[36,3],[35,4],[36,4]
        ];
        gun.forEach(([dx,dy])=>set(dx, dy));
      }
    }
  }
  // Model
  class SchellingModel {
    constructor(size, densityPct, ratioA, tolerancePct, wrapEdges) {
      this.size = size | 0;
      this.wrapEdges = !!wrapEdges;
      this.grid = new Uint8Array(this.size * this.size);
      this.tolerance = Math.min(1, Math.max(0, tolerancePct / 100));
      this.density = Math.min(1, Math.max(0, densityPct / 100));
      this.ratioA = Math.min(1, Math.max(0, ratioA / 100));
      this.stepCount = 0;
      this.randomize();
    }

    index(x, y) { return y * this.size + x; }
    inBounds(x, y) { return x >= 0 && y >= 0 && x < this.size && y < this.size; }

    randomize() {
      const n = this.size * this.size;
      const agentCells = Math.round(n * this.density);
      const aAgents = Math.round(agentCells * this.ratioA);
      const bAgents = agentCells - aAgents;

      const cells = new Array(n).fill(0);
      for (let i = 0; i < aAgents; i++) cells[i] = 1;
      for (let i = aAgents; i < aAgents + bAgents; i++) cells[i] = 2;
      shuffle(cells);
      this.grid = Uint8Array.from(cells);
      this.stepCount = 0;
    }

    neighbors(x, y) {
      let total = 0, same = 0;
      const here = this.grid[this.index(x, y)];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          let nx = x + dx, ny = y + dy;
          if (this.wrapEdges) {
            nx = (nx + this.size) % this.size;
            ny = (ny + this.size) % this.size;
          } else if (!this.inBounds(nx, ny)) {
            continue;
          }
          const v = this.grid[this.index(nx, ny)];
          if (v !== 0) {
            total++;
            if (v === here) same++;
          }
        }
      }
      return { total, same };
    }

    // Hypothetical neighbor stats if a given value were placed at (x,y)
    neighborStatsIf(x, y, value) {
      let total = 0, same = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          let nx = x + dx, ny = y + dy;
          if (this.wrapEdges) {
            nx = (nx + this.size) % this.size;
            ny = (ny + this.size) % this.size;
          } else if (!this.inBounds(nx, ny)) {
            continue;
          }
          const v = this.grid[this.index(nx, ny)];
          if (v !== 0) {
            total++;
            if (v === value) same++;
          }
        }
      }
      return { total, same };
    }

    wouldBeSatisfiedAt(x, y, value) {
      if (value === 0) return true;
      const { total, same } = this.neighborStatsIf(x, y, value);
      if (total === 0) return true;
      return (same / total) >= this.tolerance;
    }

    // Like wouldBeSatisfiedAt but accounts for the origin cell becoming empty when moving.
    neighborStatsIfMoving(fromX, fromY, toX, toY, value) {
      let total = 0, same = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          let nx = toX + dx, ny = toY + dy;
          if (this.wrapEdges) {
            nx = (nx + this.size) % this.size;
            ny = (ny + this.size) % this.size;
          } else if (!this.inBounds(nx, ny)) {
            continue;
          }
          // Skip the origin cell because it becomes empty after moving
          if (nx === fromX && ny === fromY) continue;
          const v = this.grid[this.index(nx, ny)];
          if (v !== 0) {
            total++;
            if (v === value) same++;
          }
        }
      }
      return { total, same };
    }

    wouldBeSatisfiedMoving(fromX, fromY, toX, toY, value) {
      if (value === 0) return true;
      const { total, same } = this.neighborStatsIfMoving(fromX, fromY, toX, toY, value);
      if (total === 0) return true;
      return (same / total) >= this.tolerance;
    }

    isSatisfied(x, y) {
      const v = this.grid[this.index(x, y)];
      if (v === 0) return true;
      const { total, same } = this.neighbors(x, y);
      if (total === 0) return true; // no neighbors -> satisfied
      return (same / total) >= this.tolerance;
    }

    countUnsatisfied() {
      let unsat = 0, agents = 0;
      for (let y = 0; y < this.size; y++) {
        for (let x = 0; x < this.size; x++) {
          const v = this.grid[this.index(x, y)];
          if (v !== 0) {
            agents++;
            if (!this.isSatisfied(x, y)) unsat++;
          }
        }
      }
      return { unsatisfied: unsat, agents };
    }

    step() {
      const empties = [];
      const unsatisfied = [];
      for (let y = 0; y < this.size; y++) {
        for (let x = 0; x < this.size; x++) {
          const idx = this.index(x, y);
          const v = this.grid[idx];
          if (v === 0) {
            empties.push(idx);
          } else if (!this.isSatisfied(x, y)) {
            unsatisfied.push(idx);
          }
        }
      }

      if (unsatisfied.length === 0) {
        this.stepCount++;
        return { moved: 0, unsatisfiedBefore: 0, converged: true };
      }
      if (empties.length === 0) {
        this.stepCount++;
        return { moved: 0, unsatisfiedBefore: unsatisfied.length, converged: true };
      }

      shuffle(unsatisfied);
      shuffle(empties);
      const moves = Math.min(unsatisfied.length, empties.length);
      for (let i = 0; i < moves; i++) {
        const from = unsatisfied[i];
        const to = empties[i];
        const v = this.grid[from];
        this.grid[from] = 0;
        this.grid[to] = v;
      }
      this.stepCount++;
      const { unsatisfied: uns2 } = this.countUnsatisfied();
      return { moved: moves, unsatisfiedBefore: unsatisfied.length, unsatisfiedAfter: uns2, converged: moves === 0 || uns2 === 0 };
    }
  }

  // Renderer
  const ctx = els.canvas.getContext('2d', { alpha: false });
  let model = null;
  let currentSim = 'schelling';
  // Per-simulation defaults/state for Wrap edges
  let simWrap = { schelling: false, life: true, boids: true };
  // Remember per-sim density (occupancy) preferences; defaults: Schelling 90, Life 50
  let simDensity = { schelling: 90, life: 50, boids: 50 };
  // Remember per-sim step delay (ms); default Boids=50, others=100
  let simDelay = { schelling: 100, life: 100, boids: 50 };
  let cellSize = 10; // pixels
  let view = { offsetX: 0, offsetY: 0, width: 0, height: 0 };
  let lastMove = null; // { from:{x,y}, to:{x,y}, time:number }

  function fitCanvasToDisplay() {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const rect = els.canvas.getBoundingClientRect();
    const w = Math.max(200, Math.floor(rect.width));
    const h = Math.max(200, Math.floor(rect.height));
    els.canvas.width = w * dpr;
    els.canvas.height = h * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  function drawGrid() {
    if (!model) return;
    const rect = els.canvas.getBoundingClientRect();
    const w = rect.width, h = rect.height;

    // Boids: draw in pixel space and return
    if (currentSim === 'boids') {
      // Hard clear background
      ctx.fillStyle = '#0c0f14';
      ctx.fillRect(0, 0, w, h);
      view = { offsetX: 0, offsetY: 0, width: w, height: h };
      for (const boid of model.boids) {
        const angle = Math.atan2(boid.vy, boid.vx);
        const sizePx = 6 + Math.min(10, Math.hypot(boid.vx, boid.vy));
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.moveTo(boid.x + Math.cos(angle) * sizePx, boid.y + Math.sin(angle) * sizePx);
        ctx.lineTo(boid.x + Math.cos(angle + 2.5) * sizePx * 0.6, boid.y + Math.sin(angle + 2.5) * sizePx * 0.6);
        ctx.lineTo(boid.x + Math.cos(angle - 2.5) * sizePx * 0.6, boid.y + Math.sin(angle - 2.5) * sizePx * 0.6);
        ctx.closePath();
        ctx.fill();
      }
      return;
    }

    // Clear background for grid-based sims
    ctx.fillStyle = '#0c0f14';
    ctx.fillRect(0, 0, w, h);

    const size = model.size;
    const margin = 8;
    const usable = Math.min(w, h) - margin * 2;
    cellSize = Math.max(2, Math.floor(usable / size));
    const gridW = cellSize * size;
    const offsetX = Math.floor((w - gridW) / 2);
    const offsetY = Math.floor((h - gridW) / 2);
    view = { offsetX, offsetY, width: w, height: h };

    // Draw cells
    if (currentSim === 'schelling') {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const v = model.grid[model.index(x, y)];
          let color;
          if (v === 1) color = '#2d88ff';
          else if (v === 2) color = '#ff4757';
          else color = '#2a2f3d';
          ctx.fillStyle = color;
          ctx.fillRect(offsetX + x * cellSize, offsetY + y * cellSize, cellSize, cellSize);
        }
      }
    } else {
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const alive = model.grid[model.index(x, y)] === 1;
          ctx.fillStyle = alive ? '#7ee7c4' : '#1a1f2c';
          ctx.fillRect(offsetX + x * cellSize, offsetY + y * cellSize, cellSize, cellSize);
        }
      }
    }

    // Grid overlay (subtle)
    if (cellSize >= 6) {
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 0; i <= size; i++) {
        const px = offsetX + i * cellSize + 0.5;
        ctx.moveTo(px, offsetY + 0.5);
        ctx.lineTo(px, offsetY + size * cellSize + 0.5);
        const py = offsetY + i * cellSize + 0.5;
        ctx.moveTo(offsetX + 0.5, py);
        ctx.lineTo(offsetX + size * cellSize + 0.5, py);
      }
      ctx.stroke();
    }

    // Unsatisfied markers (optional)
    if (currentSim === 'schelling' && els.showUnsatisfied && els.showUnsatisfied.checked) {
      const stroke = 'rgba(255, 209, 102, 0.9)'; // warm yellow
      ctx.lineWidth = Math.max(1, Math.floor(cellSize / 6));
      ctx.strokeStyle = stroke;
      const inset = Math.max(1.5, Math.floor(cellSize * 0.18));
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          const v = model.grid[model.index(x, y)];
          if (v === 0) continue;
          if (!model.isSatisfied(x, y)) {
            const px = offsetX + x * cellSize;
            const py = offsetY + y * cellSize;
            // small inner rectangle marker
            ctx.strokeRect(px + inset, py + inset, cellSize - inset * 2, cellSize - inset * 2);
          }
        }
      }
    }

    // Draw last move markers (fade out): elegant curved neon-green arrow with glow
    if (currentSim === 'schelling' && lastMove) {
      const age = Date.now() - lastMove.time;
      const ttl = 2200;
      if (age < ttl) {
        const alpha = Math.max(0, 1 - age / ttl);
        const from = lastMove.from; const to = lastMove.to;
        const sx = offsetX + from.x * cellSize + cellSize/2;
        const sy = offsetY + from.y * cellSize + cellSize/2;
        const tx = offsetX + to.x * cellSize + cellSize/2;
        const ty = offsetY + to.y * cellSize + cellSize/2;
        const dx = tx - sx; const dy = ty - sy;
        const len = Math.hypot(dx, dy) || 1;
        const ux = dx / len; const uy = dy / len;
        const nx = -uy; const ny = ux; // unit normal

        // Sizing, scaled to cell size only (not distance)
        const lineWidthOuter = Math.max(2, Math.floor(cellSize * 0.22));
        const lineWidthInner = Math.max(1, Math.floor(lineWidthOuter * 0.5));
        const circleOuter = Math.max(4, Math.floor(cellSize * 0.35));
        const circleInner = Math.max(2, Math.floor(circleOuter * 0.55));

        // Shaft endpoints: straight line, shortened to avoid overlap with start circle and fixed-size X
        const xHalf = Math.max(5, Math.floor(cellSize * 0.4));
        const shaftStartX = sx + ux * (circleOuter + 1);
        const shaftStartY = sy + uy * (circleOuter + 1);
        const shaftEndX = tx - ux * (xHalf + 2);
        const shaftEndY = ty - uy * (xHalf + 2);

        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Outer glow stroke
        ctx.shadowColor = `rgba(0, 255, 170, ${0.7 * alpha})`;
        ctx.shadowBlur = Math.max(8, Math.floor(cellSize * 0.8));
        ctx.strokeStyle = `rgba(0, 230, 150, ${0.55 * alpha})`;
        ctx.lineWidth = lineWidthOuter;
        ctx.beginPath();
        ctx.moveTo(shaftStartX, shaftStartY);
        ctx.lineTo(shaftEndX, shaftEndY);
        ctx.stroke();

        // Inner bright stroke
        ctx.shadowBlur = Math.max(4, Math.floor(cellSize * 0.4));
        ctx.strokeStyle = `rgba(6, 214, 160, ${0.95 * alpha})`;
        ctx.lineWidth = lineWidthInner;
        ctx.beginPath();
        ctx.moveTo(shaftStartX, shaftStartY);
        ctx.lineTo(shaftEndX, shaftEndY);
        ctx.stroke();

        // Start marker: ring + dot with glow
        ctx.fillStyle = `rgba(6, 214, 160, ${0.95 * alpha})`;
        ctx.beginPath(); ctx.arc(sx, sy, circleOuter, 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath(); ctx.arc(sx, sy, circleOuter - Math.max(2, Math.floor(circleOuter * 0.35)), 0, Math.PI * 2); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = Math.max(6, Math.floor(cellSize * 0.6));
        ctx.beginPath(); ctx.arc(sx, sy, circleInner, 0, Math.PI * 2); ctx.fill();

        // End marker: glowing 'X' at the destination (fixed orientation and size)
        const outerHead = Math.max(2, Math.floor(cellSize * 0.28));
        const innerHead = Math.max(1, Math.floor(outerHead * 0.6));

        // Outer glow for the X
        ctx.shadowBlur = Math.max(8, Math.floor(cellSize * 0.8));
        ctx.strokeStyle = `rgba(6, 214, 160, ${0.75 * alpha})`;
        ctx.lineWidth = outerHead;
        ctx.beginPath();
        ctx.moveTo(tx - xHalf, ty - xHalf);
        ctx.lineTo(tx + xHalf, ty + xHalf);
        ctx.moveTo(tx - xHalf, ty + xHalf);
        ctx.lineTo(tx + xHalf, ty - xHalf);
        ctx.stroke();

        // Inner crisp X
        ctx.shadowBlur = Math.max(4, Math.floor(cellSize * 0.4));
        ctx.strokeStyle = `rgba(6, 214, 160, ${0.98 * alpha})`;
        ctx.lineWidth = innerHead;
        ctx.beginPath();
        ctx.moveTo(tx - xHalf, ty - xHalf);
        ctx.lineTo(tx + xHalf, ty + xHalf);
        ctx.moveTo(tx - xHalf, ty + xHalf);
        ctx.lineTo(tx + xHalf, ty - xHalf);
        ctx.stroke();

        ctx.restore();
      } else {
        lastMove = null;
      }
    }
  }

  function updateStats(extra = {}) {
    if (!model) return;
    els.statStep.textContent = String(model.stepCount || 0);
    if (currentSim === 'schelling') {
      const { unsatisfied, agents } = model.countUnsatisfied();
      els.statAgents.textContent = String(agents);
      els.statUnsatisfied.textContent = String(unsatisfied);
      const satisfiedPct = agents === 0 ? 100 : Math.round(((agents - unsatisfied) / agents) * 100);
      els.statSatisfied.textContent = satisfiedPct + '%';
    } else if (currentSim === 'life') {
      const alive = model.countAlive();
      els.statAgents.textContent = String(alive);
      els.statUnsatisfied.textContent = '-';
      els.statSatisfied.textContent = '-';
    } else if (currentSim === 'boids') {
      const count = model.count();
      els.statAgents.textContent = String(count);
      els.statUnsatisfied.textContent = '-';
      els.statSatisfied.textContent = '-';
    }
    if (typeof extra.moved === 'number') {
      els.statMoved.textContent = String(extra.moved);
    }
  }

  // Controls wiring
  function syncLabels() {
    els.gridSizeValue.textContent = els.gridSize.value;
    els.gridSizeValue2.textContent = els.gridSize.value;
    els.densityValue.textContent = els.density.value;
    els.ratioAValue.textContent = els.ratioA.value;
    els.toleranceValue.textContent = els.tolerance.value;
    els.delayValue.textContent = els.delay.value;
    if (els.boidsCountValue) els.boidsCountValue.textContent = els.boidsCount.value;
    if (els.perceptionValue) els.perceptionValue.textContent = els.perception.value;
    if (els.separationDistValue) els.separationDistValue.textContent = els.separationDist.value;
    if (els.maxSpeedValue) els.maxSpeedValue.textContent = els.maxSpeed.value;
    if (els.maxForceValue) els.maxForceValue.textContent = els.maxForce.value;
    if (els.weightSepValue) els.weightSepValue.textContent = els.weightSep.value;
    if (els.weightAlignValue) els.weightAlignValue.textContent = els.weightAlign.value;
    if (els.weightCohValue) els.weightCohValue.textContent = els.weightCoh.value;
  }

  [els.gridSize, els.density, els.ratioA, els.tolerance, els.delay].forEach(inp => {
    inp.addEventListener('input', syncLabels);
  });
  [els.boidsCount, els.perception, els.separationDist, els.maxSpeed, els.maxForce, els.weightSep, els.weightAlign, els.weightCoh].forEach(inp => {
    if (!inp) return;
    inp.addEventListener('input', syncLabels);
  });

  function initModelFromControls() {
    const size = parseInt(els.gridSize.value, 10);
    const density = parseInt(els.density.value, 10);
    const wrap = !!els.wrapEdges.checked;
    if (currentSim === 'schelling') {
      const ratioA = parseInt(els.ratioA.value, 10);
      const tolerance = parseInt(els.tolerance.value, 10);
      model = new SchellingModel(size, density, ratioA, tolerance, wrap);
    } else if (currentSim === 'life') {
      model = new LifeModel(size, density, wrap);
      const pattern = els.lifePattern ? els.lifePattern.value : 'random';
      if (pattern && pattern !== 'random') model.seedPattern(pattern);
    } else if (currentSim === 'boids') {
      fitCanvasToDisplay();
      const rect = els.canvas.getBoundingClientRect();
      const opts = {
        count: parseInt(els.boidsCount.value, 10) || 150,
        width: rect.width,
        height: rect.height,
        perception: parseFloat(els.perception.value) || 50,
        separationDist: parseFloat(els.separationDist.value) || 20,
        maxSpeed: parseFloat(els.maxSpeed.value) || 2.5,
        maxForce: parseFloat(els.maxForce.value) || 0.05,
        wSep: parseFloat(els.weightSep.value) || 1.5,
        wAlign: parseFloat(els.weightAlign.value) || 1.0,
        wCoh: parseFloat(els.weightCoh.value) || 1.0,
        wrapEdges: wrap,
      };
      model = new BoidsModel(opts);
    }
    fitCanvasToDisplay();
    drawGrid();
    updateStats({ moved: 0 });
  }

  // Debounced auto-initialize when key sliders change
  let autoInitTimer = null;
  function autoInit() {
    if (running) { running = false; if (els.runBtnLabel) els.runBtnLabel.textContent = 'Run'; els.runBtn.classList.remove('running'); }
    initModelFromControls();
  }
  function debouncedAutoInit() {
    if (autoInitTimer) clearTimeout(autoInitTimer);
    autoInitTimer = setTimeout(autoInit, 150);
  }

  // Auto re-init on structural parameters: grid size, occupancy, type split
  [els.gridSize, els.density, els.ratioA].forEach(inp => {
    inp.addEventListener('input', debouncedAutoInit);
    inp.addEventListener('change', autoInit);
  });
  // Auto re-init for boids controls
  ;[els.boidsCount, els.perception, els.separationDist, els.maxSpeed, els.maxForce, els.weightSep, els.weightAlign, els.weightCoh].forEach(inp => {
    if (!inp) return;
    inp.addEventListener('input', debouncedAutoInit);
    inp.addEventListener('change', autoInit);
  });

  let running = false;
  let runPromise = null;

  async function runUntilConvergence() {
    if (!model || running) return;
    running = true;
    if (els.runBtnLabel) els.runBtnLabel.textContent = 'Pause';
    els.runBtn.classList.add('running');
    try {
      const maxSteps = Math.max(1, parseInt(els.maxIterations.value, 10) || 5000);
      const delay = Math.max(0, parseInt(els.delay.value, 10) || 0);
      for (let i = 0; i < maxSteps; i++) {
        if (!running) break;
        const stats = model.step();
        drawGrid();
        updateStats(stats);
        if (stats.converged) break;
        if (delay > 0) await new Promise(r => setTimeout(r, delay));
      }
    } finally {
      running = false;
      if (els.runBtnLabel) els.runBtnLabel.textContent = 'Run';
      els.runBtn.classList.remove('running');
    }
  }

  function stepOnce() {
    if (!model) return;
    const stats = model.step();
    drawGrid();
    updateStats(stats);
  }

  // Manual move: click a cell to move if unsatisfied
  function coordsToCell(clientX, clientY) {
    const rect = els.canvas.getBoundingClientRect();
    const cx = clientX - rect.left;
    const cy = clientY - rect.top;
    const x = Math.floor((cx - view.offsetX) / cellSize);
    const y = Math.floor((cy - view.offsetY) / cellSize);
    if (!model) return null;
    if (x < 0 || y < 0 || x >= model.size || y >= model.size) return null;
    return { x, y };
  }

  function moveOneIfUnsatisfied(x, y) {
    if (!model) return { moved: false };
    if (model.grid[model.index(x, y)] === 0) return { moved: false };
    if (model.isSatisfied(x, y)) return { moved: false, satisfied: true };
    // collect empties
    const empties = [];
    const n = model.size * model.size;
    for (let i = 0; i < n; i++) if (model.grid[i] === 0) empties.push(i);
    if (empties.length === 0) return { moved: false };

    const fromIdx = model.index(x, y);
    const v = model.grid[fromIdx];

    // distance function (Manhattan with wrap if enabled)
    function manhattanToroidal(x1, y1, x2, y2, size, wrap) {
      let dx = Math.abs(x2 - x1);
      let dy = Math.abs(y2 - y1);
      if (wrap) {
        dx = Math.min(dx, size - dx);
        dy = Math.min(dy, size - dy);
      }
      return dx + dy;
    }

    // find nearest empty that would satisfy
    let best = null;
    for (const idx of empties) {
      const tx = idx % model.size;
      const ty = Math.floor(idx / model.size);
      if (model.wouldBeSatisfiedMoving(x, y, tx, ty, v)) {
        const dist = manhattanToroidal(x, y, tx, ty, model.size, model.wrapEdges);
        if (!best || dist < best.dist) {
          best = { idx, x: tx, y: ty, dist };
        }
      }
    }

    let toIdx;
    if (best) {
      toIdx = best.idx;
    } else {
      // fallback: random empty
      toIdx = empties[Math.floor(Math.random() * empties.length)];
    }

    model.grid[fromIdx] = 0;
    model.grid[toIdx] = v;
    const to = { x: toIdx % model.size, y: Math.floor(toIdx / model.size) };
    return { moved: true, from: { x, y }, to };
  }

  // Event listeners
  els.initializeBtn.addEventListener('click', (e) => {
    e.preventDefault();
    if (running) { running = false; els.runBtn.textContent = 'Run'; }
    initModelFromControls();
  });
  els.stepBtn.addEventListener('click', (e) => {
    e.preventDefault();
    stepOnce();
  });
  els.runBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    if (running) { running = false; if (els.runBtnLabel) els.runBtnLabel.textContent = 'Run'; els.runBtn.classList.remove('running'); return; }
    await runUntilConvergence();
  });
  // Removed Fit View button; canvas auto-fits on init and resize

  if (els.showUnsatisfied) {
    els.showUnsatisfied.addEventListener('change', () => {
      drawGrid();
    });
  }

  // Simulation tabs and pattern
  function setSim(sim) {
    if (sim === currentSim) return;
    // Store current density and wrap under currentSim
    if (els.density) {
      const curVal = parseInt(els.density.value, 10);
      if (!Number.isNaN(curVal)) simDensity[currentSim] = curVal;
    }
    if (els.wrapEdges) {
      simWrap[currentSim] = !!els.wrapEdges.checked;
    }
    // Store current delay
    if (els.delay) {
      const curDelay = parseInt(els.delay.value, 10);
      if (!Number.isNaN(curDelay)) simDelay[currentSim] = curDelay;
    }
    currentSim = sim;
    // Update body class for robust CSS-based toggling
    document.body.classList.toggle('sim-schelling', sim === 'schelling');
    document.body.classList.toggle('sim-life', sim === 'life');
    document.body.classList.toggle('sim-boids', sim === 'boids');
    // Apply target sim default/last density
    if (els.density) {
      const next = simDensity[sim] ?? (sim === 'life' ? 50 : 90);
      els.density.value = String(next);
      if (els.densityValue) els.densityValue.textContent = String(next);
    }
    // Apply target sim default/last wrap
    if (els.wrapEdges) {
      const nextWrap = simWrap[sim];
      els.wrapEdges.checked = (typeof nextWrap === 'boolean') ? nextWrap : (sim === 'life');
    }
    // Apply target sim default/last delay
    if (els.delay) {
      const nextDelay = simDelay[sim] ?? 100;
      els.delay.value = String(nextDelay);
      if (els.delayValue) els.delayValue.textContent = String(nextDelay);
    }
    if (els.tabSchelling && els.tabLife) {
      els.tabSchelling.classList.toggle('active', sim === 'schelling');
      els.tabLife.classList.toggle('active', sim === 'life');
    }
    if (els.tabBoids) {
      els.tabBoids.classList.toggle('active', sim === 'boids');
    }
    if (els.schellingPanel) els.schellingPanel.hidden = sim !== 'schelling';
    if (els.lifePanel) els.lifePanel.hidden = sim !== 'life';
    if (els.boidsPanel) els.boidsPanel.hidden = sim !== 'boids';
    if (els.unsatRow) els.unsatRow.style.display = (sim === 'schelling') ? '' : 'none';
    // Toggle common grid controls visibility (not used by Boids)
    const gridSizeGroup = document.getElementById('gridSizeGroup');
    const densityGroup = document.getElementById('densityGroup');
    const showGridControls = (sim !== 'boids');
    if (gridSizeGroup) gridSizeGroup.style.display = showGridControls ? '' : 'none';
    if (densityGroup) densityGroup.style.display = showGridControls ? '' : 'none';
    if (els.schellingRules) els.schellingRules.hidden = sim !== 'schelling';
    if (els.lifeRules) els.lifeRules.hidden = sim !== 'life';
    if (els.boidsRules) els.boidsRules.hidden = sim !== 'boids';
    if (els.schellingLegend) els.schellingLegend.hidden = sim !== 'schelling';
    if (els.lifeLegend) els.lifeLegend.hidden = sim !== 'life';
    if (els.boidsLegend) els.boidsLegend.hidden = sim !== 'boids';
    // Update the per-simulation title link
    updateSimTitle();
    autoInit();
  }
  if (els.tabSchelling && els.tabLife) {
    els.tabSchelling.addEventListener('click', ()=>setSim('schelling'));
    els.tabLife.addEventListener('click', ()=>setSim('life'));
  }
  if (els.tabBoids) {
    els.tabBoids.addEventListener('click', ()=>setSim('boids'));
  }
  if (els.lifePattern) {
    els.lifePattern.addEventListener('change', () => {
      if (currentSim === 'life') initModelFromControls();
    });
  }

  // Sim title link updater
  function updateSimTitle() {
    if (!els.simTitle) return;
    els.simTitle.classList.remove('schelling','life','boids');
    if (currentSim === 'schelling') {
      els.simTitle.textContent = "Schelling's Model of Segregation";
      els.simTitle.href = 'https://en.wikipedia.org/wiki/Schelling%27s_model_of_segregation';
      els.simTitle.classList.add('schelling');
    } else if (currentSim === 'life') {
      els.simTitle.textContent = "Conway's Game of Life";
      els.simTitle.href = 'https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life';
      els.simTitle.classList.add('life');
    } else if (currentSim === 'boids') {
      els.simTitle.textContent = "Reynolds' Boids";
      els.simTitle.href = 'https://en.wikipedia.org/wiki/Boids';
      els.simTitle.classList.add('boids');
    }
  }
  // End sim switching


  els.canvas.addEventListener('click', (e) => {
    const cell = coordsToCell(e.clientX, e.clientY);
    if (currentSim === 'schelling') {
      if (!cell) return;
      const res = moveOneIfUnsatisfied(cell.x, cell.y);
      if (res && res.moved) {
        lastMove = { from: res.from, to: res.to, time: Date.now() };
        drawGrid();
        updateStats({ moved: 1 });
      }
    } else if (currentSim === 'life') {
      if (!cell) return;
      // Toggle cell for Game of Life
      const idx = model.index(cell.x, cell.y);
      model.grid[idx] = model.grid[idx] ? 0 : 1;
      drawGrid();
      updateStats({});
    } else if (currentSim === 'boids') {
      const rect = els.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      model.boids.push({ x, y, vx: (Math.random()*2-1)*model.maxSpeed, vy: (Math.random()*2-1)*model.maxSpeed });
      drawGrid();
    }
  });

  window.addEventListener('resize', () => {
    fitCanvasToDisplay();
    drawGrid();
  });

  // Boot
  syncLabels();
  // Set initial body class based on default simulation
  document.body.classList.add('sim-schelling');
  // Ensure per-sim default wrap is applied before first init
  if (els.wrapEdges) els.wrapEdges.checked = !!simWrap[currentSim];
  initModelFromControls();
  fitCanvasToDisplay();
  // Ensure sim title reflects current selection
  if (typeof updateSimTitle === 'function') updateSimTitle();
  drawGrid();
})();

</script>
  </body>
  </html>
